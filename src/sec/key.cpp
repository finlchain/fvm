/**
 * Description : 
 *
 * @date 2021/01/21
 * @author FINL Chain Team
 * @version 1.0
 */

#include "global.hpp"

#define BUFFER_SIZE 100

void crt_wcstombs_test(void)
{
    size_t  count;
    char    *pMBBuffer = (char *)malloc( BUFFER_SIZE );
    wchar_t *pWCBuffer = (wchar_t *)L"Hello, world.";

    printf("Convert wide-character string:\n" );

    count = wcstombs(pMBBuffer, pWCBuffer, BUFFER_SIZE ); // C4996
    // Note: wcstombs is deprecated; consider using wcstombs_s instead
    printf("   Characters converted: %u\n", (uint32_t)count );
    printf("    Multibyte character: %s\n\n", pMBBuffer );

    free(pMBBuffer);
}

void crt_mbstowcs_test(void)
{
    size_t size;
    // int nChar = 2; // number of characters to convert
    int requiredSize;

    // unsigned char    *pmbnull  = NULL;
    unsigned char    *pmbhello = NULL;
    char* localeInfo;

    // wchar_t *pwchello = (wchar_t *)L"\x3042\x3043"; // 2 Hiragana characters
    wchar_t *pwchello = (wchar_t *)L"한국"; // 2 Hiragana characters
    wchar_t *pwc;

    /* Enable the Japanese locale and codepage */
    // Check $locale -a in console windows
    localeInfo = setlocale(LC_ALL, "C.UTF-8"); // C.UTF-8 ko_KR.utf8
    printf("Locale information set to %s\n", localeInfo);

    printf( "Convert to multibyte string:\n" );

    requiredSize = wcstombs( NULL, pwchello, 0); // C4996
    // Note: wcstombs is deprecated; consider using wcstombs_s
    printf("   Required Size: %d\n", requiredSize);

    /* Add one to leave room for the null terminator. */
    pmbhello = (unsigned char *)malloc( requiredSize + 1);
    if (! pmbhello)
    {
        printf("Memory allocation failure.\n");
        return;
    }
    size = wcstombs( (char *)pmbhello, pwchello, requiredSize + 1); // C4996
    // Note: wcstombs is deprecated; consider using wcstombs_s
    if (size == (size_t) (-1))
    {
        printf("Couldn't convert string. Code page 932 may"
                " not be available.\n");
        return;
    }
    printf( "   Number of bytes written to multibyte string: %u\n",
            (unsigned int) size );
    printf( "   Hex values of the" );
    printf( " multibyte characters: %#.2x %#.2x %#.2x %#.2x\n",
            pmbhello[0], pmbhello[1], pmbhello[2], pmbhello[3] );
    printf( "   Codepage 932 uses 0x81 to 0x9f as lead bytes.\n\n");

    printf( "Convert back to wide-character string:\n" );

    /* Assume we don't know the length of the multibyte string.
     Get the required size in characters, and allocate enough space. */

    requiredSize = mbstowcs(NULL, (char *)pmbhello, 0); // C4996
    /* Add one to leave room for the null terminator */
    pwc = (wchar_t *)malloc( (requiredSize + 1) * sizeof( wchar_t ));
    if (! pwc)
    {
        printf("Memory allocation failure.\n");
        return;
    }
    size = mbstowcs( pwc, (char *)pmbhello, requiredSize + 1); // C4996
    if (size == (size_t) (-1))
    {
       printf("Couldn't convert string--invalid multibyte character.\n");
    }
    printf( "   Characters converted: %u\n", (unsigned int)size );
    printf( "   Hex value of first 2" );
    printf( " wide characters: %#.4x %#.4x\n\n", pwc[0], pwc[1] );

    free(pwc);
    free(pmbhello);
}

//
int32_t key_fip39_seed(char *p_pw, int32_t pw_len, char *p_salt, int32_t salt_len, uint32_t *p_rand_num, char *p_seed)
{
    // up to 32768 (cautionary) that can be generated by random numbers
    uint16_t rand_num = 0;

    if (*p_rand_num <= 0)
    {
        rand_num = util_randint(0x1FF, 0xFFFF);
    }
    else
    {
        rand_num = (uint16_t)(*p_rand_num);
    }

    //
    int32_t idx;
    uint16_t xor_rn;

    //
    int32_t pw_xor_len = pw_len;
    if (pw_len % 2)
    {
        pw_xor_len++;
    }

    //
    char *p_pw_new = (char *)MALLOC_M(pw_xor_len);
    char *p_pw_xor = (char *)MALLOC_M(pw_xor_len);

    MEMCPY_M(p_pw_new, p_pw, pw_len);

    for (idx = 0; idx < pw_xor_len; idx += SEED_RAND_NUM_LEN)
    {
        if (idx != 0)
        {
            xor_rn = p_pw_new[idx-SEED_RAND_NUM_LEN];
        }
        else
        {
            xor_rn = rand_num;
        }

        xor_m(&p_pw_xor[idx], &p_pw_new[idx], &xor_rn, SEED_RAND_NUM_LEN);
    }
    
    FREE_M(p_pw_new);

    //
    int32_t salt_xor_len = salt_len;
    if (salt_len % 2)
    {
        salt_xor_len++;
    }

    //
    char *p_salt_new = (char *)MALLOC_M(salt_xor_len);
    char *p_salt_xor = (char *)MALLOC_M(salt_xor_len);

    MEMCPY_M(p_salt_new, p_salt, salt_len);

    for (idx = 0; idx < salt_xor_len; idx += SEED_RAND_NUM_LEN)
    {
        if (idx != 0)
        {
            xor_rn = p_salt_new[idx-SEED_RAND_NUM_LEN];
        }
        else
        {
            xor_rn = rand_num;
        }

        xor_m(&p_salt_xor[idx], &p_salt_new[idx], &xor_rn, SEED_RAND_NUM_LEN);
    }
    
    FREE_M(p_salt_new);
    

    // uint8_t binResult[PBKDF2_HMAC_SHA_512_MAX_SIZE];
    // memset(binResult, 0, PBKDF2_HMAC_SHA_512_MAX_SIZE);

    char hexResult[PBKDF2_HMAC_SHA_512_MAX_STR_SIZE];
    // char *hexResult = (char*)malloc(PBKDF2_HMAC_SHA_512_MAX_STR_SIZE);
    memset(hexResult, 0, PBKDF2_HMAC_SHA_512_MAX_STR_SIZE);

    //
    pbkdf2_hmac_sha512(p_pw_xor, pw_xor_len, (uint8_t *)p_salt_xor, salt_xor_len, 2048, PBKDF2_HMAC_SHA_512_MAX_SIZE, hexResult, (uint8_t *)p_seed);

    DBG_PRINT(DBG_UTIL, DBG_NONE, (void *)"hexResult : (%s)\n",  hexResult);

    FREE_M(p_pw_xor);
    FREE_M(p_salt_xor);

    *p_rand_num = (uint32_t)rand_num;

    return (SUCCESS_);
}

#define FIP32_KEY "Finlchain seed"
#define BC_KEY "Bitcoin seed"
#define NIST_KEY  "Nist256p1 seed"
//
int32_t key_fip32_master(char *p_seed, int32_t seed_len, uint8_t *p_mac_out)
{
    //
    int32_t mac_out_len = 0;

    //
    uint8_t *p_master_secret_mbs;
    int32_t master_secret_mbs_size;
    p_master_secret_mbs = util_cstombs((char *)"C.UTF-8", (char *)FIP32_KEY, &master_secret_mbs_size);
    if (!p_master_secret_mbs)
    {
        return (mac_out_len);
    }

    DBG_DUMP(DBG_UTIL, DBG_INFO, (void *)"p_master_secret_mbs : ", p_master_secret_mbs, master_secret_mbs_size);

    //
    HMAC(EVP_sha512(), (uint8_t *)p_master_secret_mbs, master_secret_mbs_size, (uint8_t *)p_seed, seed_len, p_mac_out, (uint32_t *)&mac_out_len);
    DBG_DUMP(DBG_UTIL, DBG_INFO, (void *)"p_mac_out : ", p_mac_out, mac_out_len);

    FREE_M(p_master_secret_mbs);

    return (mac_out_len);
}

int32_t key_master(char *p_pw_str, char *p_mnemonic1_str, char *p_mnemonic2_str, uint32_t *p_rand_num, uint8_t *p_chain_code)
{
    int32_t ret = ERROR_;
    //
    int32_t pw_str_len = STRLEN_M(p_pw_str);
    int32_t mnemonic1_str_len = STRLEN_M(p_mnemonic1_str);
    int32_t mnemonic2_str_len = STRLEN_M(p_mnemonic2_str);

    if (pw_str_len < 10)
    {
        return (ret);
    }

    if ((mnemonic1_str_len < 20) || (500 < mnemonic1_str_len))
    {
        return (ret);
    }

    if ((mnemonic2_str_len < 20) || (500 < mnemonic2_str_len))
    {
        return (ret);
    }

    //
    int32_t pw_mbs_size;
    int32_t mnemonic1_mbs_size;
    int32_t mnemonic2_mbs_size;

    uint8_t *p_pw_mbs;
    uint8_t *p_mnemonic1_mbs;
    uint8_t *p_mnemonic2_mbs;

    p_pw_mbs = util_cstombs((char *)"C.UTF-8", p_pw_str, &pw_mbs_size);
    if (!p_pw_mbs)
    {
        return (ret);
    }

    p_mnemonic1_mbs = util_cstombs((char *)"C.UTF-8", p_mnemonic1_str, &mnemonic1_mbs_size);
    if (!p_mnemonic1_mbs)
    {
        FREE_M(p_pw_mbs);
        return (ret);
    }

    p_mnemonic2_mbs = util_cstombs((char *)"C.UTF-8", p_mnemonic2_str, &mnemonic2_mbs_size);
    if (!p_mnemonic2_mbs)
    {
        FREE_M(p_pw_mbs);
        FREE_M(p_mnemonic1_mbs);
        return (ret);
    }

    // DBG_DUMP(DBG_UTIL, DBG_INFO, (void *)"p_pw_mbs : ", p_pw_mbs, pw_mbs_size);
    // DBG_DUMP(DBG_UTIL, DBG_INFO, (void *)"p_mnemonic1_mbs : ", p_mnemonic1_mbs, mnemonic1_mbs_size);
    // DBG_DUMP(DBG_UTIL, DBG_INFO, (void *)"p_mnemonic2_mbs : ", p_mnemonic2_mbs, mnemonic2_mbs_size);

    // salt
    // sha256(InputMnemonic1) + sha256(InputMnemonic2) = (string)
    uint8_t hash_mnemonic[SALT_SIZE];

    // Mnemnonic Hash
    // openssl_sha256(&hash_mnemonic[0], (uint8_t *)p_mnemonic1_mbs, mnemonic2_mbs_size);
    // openssl_sha256(&hash_mnemonic[HASH_SIZE], (uint8_t *)p_mnemonic2_mbs, mnemonic2_str_len);
    openssl_sha256(&hash_mnemonic[0], (uint8_t *)p_mnemonic1_mbs, mnemonic1_mbs_size);
    openssl_sha256(&hash_mnemonic[HASH_SIZE], (uint8_t *)p_mnemonic2_mbs, mnemonic2_mbs_size);

    DBG_DUMP(DBG_UTIL, DBG_INFO, (void *)"hash_mnemonic : ", hash_mnemonic, SALT_SIZE);

    // FIP39
    uint8_t seed[PBKDF2_HMAC_SHA_512_MAX_SIZE];
    key_fip39_seed((char *)p_pw_mbs, pw_mbs_size, (char *)hash_mnemonic, SALT_SIZE, p_rand_num, (char *)seed);

    DBG_PRINT(DBG_UTIL, DBG_INFO, (void *)"*p_rand_num : (%d)\n",  *p_rand_num);
    // DBG_PRINT(DBG_UTIL, DBG_INFO, (void *)"p_seed : (%s)\n",  p_seed);
    DBG_DUMP(DBG_UTIL, DBG_INFO, (void *)"seed : ", seed, PBKDF2_HMAC_SHA_512_MAX_SIZE);

    // FIP32 Master
    // uint8_t chain_code[HMAC_SHA_512_MAX_SIZE];
    int32_t chain_code_len;

    chain_code_len = key_fip32_master((char *)seed, PBKDF2_HMAC_SHA_512_MAX_SIZE, p_chain_code);
    DBG_DUMP(DBG_UTIL, DBG_INFO, (void *)"p_chain_code : ", p_chain_code, chain_code_len);

    FREE_M(p_pw_mbs);
    FREE_M(p_mnemonic1_mbs);
    FREE_M(p_mnemonic2_mbs);

    ret = chain_code_len;

    return (ret);
}


/////////////////////////////////////////////////////////////////////////////////////////

//
int32_t key_fip39_seed_ori(char *p_pw, int32_t pw_len, char *p_salt, int32_t salt_len, char *p_seed)
{
    char hexResult[PBKDF2_HMAC_SHA_512_MAX_STR_SIZE];
    // char *hexResult = (char*)malloc(PBKDF2_HMAC_SHA_512_MAX_STR_SIZE);
    memset(hexResult, 0, PBKDF2_HMAC_SHA_512_MAX_STR_SIZE);

    //
    pbkdf2_hmac_sha512(p_pw, pw_len, (uint8_t *)p_salt, salt_len, 2048, PBKDF2_HMAC_SHA_512_MAX_SIZE, hexResult, (uint8_t *)p_seed);

    DBG_PRINT(DBG_UTIL, DBG_NONE, (void *)"hexResult : (%s)\n",  hexResult);

    return (SUCCESS_);
}

int32_t key_master_ori(char *p_mnemonic1_str, char *p_salt_str, uint8_t *p_chain_code)
{
    int32_t ret = ERROR_;
    //
    int32_t salt_str_len = STRLEN_M(p_salt_str);
    int32_t mnemonic1_str_len = STRLEN_M(p_mnemonic1_str);

    DBG_PRINT(DBG_UTIL, DBG_INFO, (void *)"len (%d) , p_mnemonic1_str (%s)\n", mnemonic1_str_len, p_mnemonic1_str);

    if (salt_str_len < 10)
    {
        return (ret);
    }

    if ((mnemonic1_str_len < 20) || (500 < mnemonic1_str_len))
    {
        return (ret);
    }

    //
    int32_t salt_mbs_size;
    int32_t mnemonic1_mbs_size;

    uint8_t *p_salt_mbs;
    uint8_t *p_mnemonic1_mbs;

    //
    static char mnmnc_str[] = "mnemonic";
    int32_t mnmnc_str_len = STRLEN_M(mnmnc_str);

    char *p_salt_str_mnmnc = (char *)MALLOC_M(mnmnc_str_len + salt_str_len + 1);
    sprintf(&p_salt_str_mnmnc[0], "%s", mnmnc_str);
    sprintf(&p_salt_str_mnmnc[mnmnc_str_len], "%s", p_salt_str);
    int32_t salt_str_mnmnc_len = STRLEN_M(p_salt_str_mnmnc);

    DBG_PRINT(DBG_UTIL, DBG_INFO, (void *)"salt_str_mnmnc_len : (%d), p_salt_str_mnmnc : (%s)\n", salt_str_mnmnc_len, p_salt_str_mnmnc);

    p_salt_mbs = util_cstombs((char *)"C.UTF-8", p_salt_str_mnmnc, &salt_mbs_size);
    if (!p_salt_mbs)
    {
        return (ret);
    }

    p_mnemonic1_mbs = util_cstombs((char *)"C.UTF-8", p_mnemonic1_str, &mnemonic1_mbs_size);
    if (!p_mnemonic1_mbs)
    {
        FREE_M(p_salt_mbs);
        return (ret);
    }

    DBG_DUMP(DBG_UTIL, DBG_INFO, (void *)"p_salt_mbs : ", p_salt_mbs, salt_mbs_size);
    DBG_DUMP(DBG_UTIL, DBG_INFO, (void *)"p_mnemonic1_mbs : ", p_mnemonic1_mbs, mnemonic1_mbs_size);

    //
    char *p_mnemonic1_mbs_norm = (char *)utf8proc_NFKD(p_mnemonic1_mbs);
    int32_t mnemonic1_mbs_norm_len = STRLEN_M(p_mnemonic1_mbs_norm);
    DBG_PRINT(DBG_UTIL, DBG_INFO, (void *)"p_mnemonic1 NFKD : (%s)\n", p_mnemonic1_mbs_norm);
    DBG_DUMP(DBG_UTIL, DBG_INFO, (void *)"p_mnemonic1_mbs_norm : ", (uint8_t *)p_mnemonic1_mbs_norm, mnemonic1_mbs_norm_len);

    char *p_salt_mbs_norm = (char *)utf8proc_NFKD(p_salt_mbs);
    int32_t salt_mbs_norm_len = STRLEN_M(p_salt_mbs_norm);
    DBG_PRINT(DBG_UTIL, DBG_INFO, (void *)"p_salt NFKD : (%s)\n", p_salt_mbs_norm);
    DBG_DUMP(DBG_UTIL, DBG_INFO, (void *)"p_mnemonic1_mbs_norm_str : ", (uint8_t *)p_salt_mbs_norm, salt_mbs_norm_len);

    // FIP39
    uint8_t seed[PBKDF2_HMAC_SHA_512_MAX_SIZE];
    key_fip39_seed_ori((char *)p_mnemonic1_mbs_norm, mnemonic1_mbs_norm_len, (char *)p_salt_mbs_norm, salt_mbs_norm_len, (char *)seed);

    // DBG_PRINT(DBG_UTIL, DBG_INFO, (void *)"p_seed : (%s)\n",  p_seed);
    DBG_DUMP(DBG_UTIL, DBG_INFO, (void *)"seed : ", seed, PBKDF2_HMAC_SHA_512_MAX_SIZE);

    // FIP32 Master
    // uint8_t chain_code[HMAC_SHA_512_MAX_SIZE];
    int32_t chain_code_len;

    chain_code_len = key_fip32_master((char *)seed, PBKDF2_HMAC_SHA_512_MAX_SIZE, p_chain_code);
    DBG_DUMP(DBG_UTIL, DBG_INFO, (void *)"p_chain_code : ", p_chain_code, chain_code_len);

    FREE_M(p_salt_mbs);
    FREE_M(p_mnemonic1_mbs);
    FREE_M(p_mnemonic1_mbs_norm);
    FREE_M(p_salt_mbs_norm);

    ret = chain_code_len;

    return (ret);
}